这段代码中，关于“由于缺乏历史行情而采用近似计算”的逻辑位于 **`PortfolioBacktestEngine` 类的 `run` 方法** 中。

### 1. 具体的代码位置
主要体现在 **第 206 行至 第 215 行**（根据你提供的代码片段）：

```javascript
            // 计算当日市值
            let stockMv = 0;
            for (let code in positions) {
                const qty = positions[code];
                // 如果当日没有交易，价格沿用之前的。
                // *优化*：此处最好能获取当日收盘价，但为减少API请求，暂用最近一次交易价近似
                // 或使用全局 fetchPrice 获取当前价（如果是最后一天）
                let price = lastPrices[code] || 0; // <--- 关键点在这里
                stockMv += qty * price;
            }
```

**为什么说这里不完整？**
这里的 `lastPrices[code]` 只有在**发生交易（买或卖）的那一天**才会更新（见代码第 196 行 `lastPrices[f.code] = f.price`）。
这意味着：如果你在 1 月 1 日以 100 元买入，之后一直持有不动，直到 1 月 30 日。在 1 月 2 日到 1 月 29 日期间，代码会一直认为该股票价格是 100 元。你的净值曲线在这段时间会是一条直线，而实际上市场价格每天都在波动。

---

### 2. 如果要精确计算，具体需要什么字段？

为了让回测曲线精确反映历史波动，你需要引入一个**外部的历史行情数据源**（通常是一个巨大的 JSON 对象、数据库或 API 接口）。

具体需要的数据结构通常是 **“日期 -> 股票代码 -> 价格”** 的映射。

需要的核心字段如下：

#### 必须字段：
1.  **日期 (Date)**：
    *   需要覆盖你回测的每一天（例如 `2023-01-01`, `2023-01-02`...）。
2.  **股票代码 (Stock Code)**：
    *   用于匹配你持仓中的股票。
3.  **复权收盘价 (Adjusted Closing Price)**：
    *   **最重要**。必须是“收盘价”。
    *   最好是“后复权”或“前复权”价格，以剔除分红和拆股造成的价格跳空影响。

#### 理想的数据结构示例：
如果前端有这样一份数据（MarketMap），代码就可以修改为精确计算：

```json
// 理想的历史行情数据结构 (MarketHistory)
{
  "2023-01-01": {
    "SH600519": 1700.50,
    "HK00700": 350.20
  },
  "2023-01-02": {
    "SH600519": 1710.00,
    "HK00700": 360.00
  }
  // ... 每一天的数据
}
```

#### 修改后的逻辑（伪代码）：

```javascript
// 修改前：
let price = lastPrices[code] || 0;

// 修改后（如果有完整数据）：
// 优先取当日收盘价，取不到（例如停牌）才取最近一次价格
let marketPrice = MarketHistory[date] && MarketHistory[date][code];
let price = marketPrice || lastPrices[code] || 0;
```

### 总结
当前代码的逻辑是 **“以最近一次交易价作为当前市价”**。
若要修复此缺陷，需要补充 **所有持仓股票** 在 **每一天** 的 **收盘价**。
