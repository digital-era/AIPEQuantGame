<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>QuantGuardians æµè§ˆå™¨ç«¯å›æµ‹</title>
    <!-- å¼•å…¥å¿…è¦çš„åº“ -->
    <script src="https://gosspublic.alicdn.com/aliyun-oss-sdk-6.17.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.2/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>

    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        #log { background: #f4f4f4; border: 1px solid #ddd; padding: 10px; height: 500px; overflow-y: scroll; font-family: monospace; white-space: pre-wrap; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; }
        button:disabled { background: #ccc; }
        .error { color: red; }
        .success { color: green; }
    </style>
</head>
<body>

    <h1>QuantGuardians æ¨¡å‹è¯„ä¼°ä¸åŒæ­¥ (æµè§ˆå™¨ç‰ˆ)</h1>
    <p>æ³¨æ„ï¼šè¯·ç¡®ä¿ OSS Bucket å·²é…ç½® CORS è·¨åŸŸè§„åˆ™ã€‚</p>
    
    <div style="margin-bottom: 20px;">
        <button id="startBtn" onclick="startProcess()">ğŸš€ å¼€å§‹è¿è¡Œä»»åŠ¡</button>
    </div>

    <h3>è¿è¡Œæ—¥å¿—:</h3>
    <div id="log">ç­‰å¾…å¼€å§‹...</div>

<script>
// ==================================================================================
// 1. é…ç½®ä¿¡æ¯ (è¯·è‡ªè¡Œæ›¿æ¢ Key)
// ==================================================================================
const CONFIG = {
    // OSSç›¸å…³é…ç½®æ”¾åœ¨å¤–å›´    

    
    // è·¯å¾„é…ç½®
    OSS_REMOTE_PATH: 'AIPEQuantGuardiansPortfolio.xlsx',
    OSS_JSON_PATH: 'QuantGuardiansç»¼åˆè¯„ä¼°.json',
    OSS_HK_DATA_PATH: 'EEIFlowHK.xlsx', // å‡è®¾æ¸¯è‚¡æ•°æ®ä¹Ÿåœ¨ OSS ä¸Šï¼Œå› ä¸ºæµè§ˆå™¨è¯»å–ä¸äº†æœ¬åœ°è·¯å¾„
    
    INITIAL_CAPITAL: 100000.0
};

const STRATEGY_MAP = {
    'genbu':  { sheet_flow: 'ä½æ³¢OR', sheet_snap: 'ä½æ³¢', name: 'ä½æ³¢' },
    'suzaku': { sheet_flow: 'å¤§æˆOR', sheet_snap: 'å¤§æˆ', name: 'å¤§æˆ' },
    'sirius': { sheet_flow: 'æµå…¥OR', sheet_snap: 'æµå…¥', name: 'æµå…¥' },
    'kirin':  { sheet_flow: 'å¤§æ™ºOR', sheet_snap: 'å¤§æ™º', name: 'å¤§æ™º' }
};

// æ—¥å¿—å·¥å…·
function log(msg, type = 'info') {
    const logDiv = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    let color = 'black';
    if (type === 'error') color = 'red';
    if (type === 'success') color = 'green';
    
    logDiv.innerHTML += `<div style="color:${color}">[${time}] ${msg}</div>`;
    logDiv.scrollTop = logDiv.scrollHeight;
    console.log(`[${time}] ${msg}`);
}

// åˆå§‹åŒ– OSS å®¢æˆ·ç«¯
const client = new OSS({
    region: CONFIG.REGION,
    accessKeyId: CONFIG.ACCESS_KEY_ID,
    accessKeySecret: CONFIG.ACCESS_KEY_SECRET,
    bucket: CONFIG.BUCKET_NAME
});

// ==================================================================================
// 2. æ ¸å¿ƒç±»ï¼šå›æµ‹å¼•æ“
// ==================================================================================
class PortfolioBacktest {
    constructor(flowData, snapData, marketDataMap, hkDataMap) {
        this.cash = CONFIG.INITIAL_CAPITAL;
        this.positions = {}; 
        this.history = [];
        this.marketMap = {...marketDataMap}; // æ·±æ‹·è´ä¸€ä»½åŸºç¡€Aè‚¡è¡Œæƒ…

        // åˆå¹¶æ¸¯è‚¡è¡Œæƒ…åˆ° marketMap
        // hkDataMap ç»“æ„: { 'YYYY-MM-DD': { '09660': 12.5, ... } }
        for (let date in hkDataMap) {
            if (!this.marketMap[date]) this.marketMap[date] = {};
            Object.assign(this.marketMap[date], hkDataMap[date]);
        }
        
        // é¢„å¤„ç†æ•°æ®
        this.flows = flowData.map(r => ({
            ...r,
            code: String(r['è‚¡ç¥¨ä»£ç ']).trim(),
            date: r['ä¿®æ”¹æ—¶é—´'] ? String(r['ä¿®æ”¹æ—¶é—´']).substring(0, 8) : null, // YYYYMMDD
            dateFmt: r['ä¿®æ”¹æ—¶é—´'] ? moment(String(r['ä¿®æ”¹æ—¶é—´']).substring(0, 8), 'YYYYMMDD').format('YYYY-MM-DD') : null
        })).filter(r => r.dateFmt);

        this.snap = snapData.map(r => ({
            ...r,
            code: String(r['è‚¡ç¥¨ä»£ç ']).trim()
        }));

        this.allDates = Object.keys(this.marketMap).sort();
    }

    run() {
        let prevTotalEquity = CONFIG.INITIAL_CAPITAL;
        let initializedFromSnap = false;

        for (const date of this.allDates) {
            const dailyPrices = this.marketMap[date] || {};

            // --- A: åˆå§‹æŒä»“ ---
            if (!initializedFromSnap) {
                for (const row of this.snap) {
                    const code = row.code;
                    if (code === '100000' || String(row['è‚¡ç¥¨åç§°']).includes('ç°é‡‘')) continue;

                    const weight = (parseFloat(row['é…ç½®æ¯”ä¾‹ (%)']) || 0) / 100.0;
                    const price = dailyPrices[code];

                    if (price && price > 0 && weight > 0) {
                        const qty = Math.floor((CONFIG.INITIAL_CAPITAL * weight) / price);
                        this.positions[code] = qty;
                        this.cash -= (qty * price);
                    }
                }
                initializedFromSnap = true;
            }

            // --- B: å½“æ—¥äº¤æ˜“ ---
            const dailyFlows = this.flows.filter(f => f.dateFmt === date);
            const activeStocks = [];

            for (const row of dailyFlows) {
                const code = row.code;
                const opType = row['æ“ä½œç±»å‹'];
                const price = parseFloat(row['ä»·æ ¼']);
                const qty = parseFloat(row['æ ‡çš„æ•°é‡']);

                if (opType === 'Buy') {
                    this.cash -= (price * qty);
                    this.positions[code] = (this.positions[code] || 0) + qty;
                    activeStocks.push(`ä¹°å…¥${row['è‚¡ç¥¨åç§°']}`);
                } else if (opType === 'Sell') {
                    this.cash += (price * qty);
                    if (this.positions[code]) {
                        this.positions[code] -= qty;
                        if (this.positions[code] <= 0) delete this.positions[code];
                    }
                    activeStocks.push(`å–å‡º${row['è‚¡ç¥¨åç§°']}`);
                }
            }

            // --- C: è®¡ç®—èµ„äº§ ---
            let currentHoldingsMv = 0.0;
            for (const [code, qty] of Object.entries(this.positions)) {
                let p = dailyPrices[code];
                // è¡Œæƒ…ç¼ºå¤±å¤„ç†ï¼šå°è¯•ç”¨å½“æ—¥æµæ°´ä»·æ ¼
                if (!p) {
                    const flowMatch = dailyFlows.find(f => f.code === code);
                    p = flowMatch ? parseFloat(flowMatch['ä»·æ ¼']) : 0;
                }
                currentHoldingsMv += (qty * (p || 0));
            }

            const currentTotalEquity = this.cash + currentHoldingsMv;
            // é¿å…é™¤ä»¥0
            const dailyRtn = prevTotalEquity > 0 ? (currentTotalEquity - prevTotalEquity) / prevTotalEquity : 0;

            this.history.push({
                'æ—¥æœŸ': date,
                'æ¯æ—¥æ”¶ç›Šç‡': dailyRtn,
                'æ€»èµ„äº§': currentTotalEquity,
                'æŒä»“å¸‚å€¼': currentHoldingsMv,
                'ç°é‡‘ä½™é¢': this.cash,
                'åŠ¨æ€å¤‡æ³¨': activeStocks.length ? activeStocks.join(',') : "æŒä»“éšç›˜æ³¢åŠ¨"
            });

            prevTotalEquity = currentTotalEquity;
        }
        return this.history;
    }
}

// ==================================================================================
// 3. è¾…åŠ©å‡½æ•°
// ==================================================================================

// ExcelJS Worksheet è½¬ JSON Array
function sheetToJson(worksheet) {
    const data = [];
    let headers = [];
    if(!worksheet) return [];
    
    worksheet.eachRow((row, rowNumber) => {
        const rowValues = row.values; // ExcelJS values ç´¢å¼•ä» 1 å¼€å§‹
        if (rowNumber === 1) {
            // æ¸…æ´—è¡¨å¤´
            headers = (rowValues || []).map(v => v ? String(v).trim() : null);
        } else {
            const rowData = {};
            // cellIndex ä» 1 å¼€å§‹
            row.eachCell((cell, colNumber) => {
                const header = headers[colNumber];
                if (header) {
                    let val = cell.value;
                    // å¤„ç†å…¬å¼æˆ–å¯Œæ–‡æœ¬
                    if (val && typeof val === 'object') {
                        if (val.result !== undefined) val = val.result;
                        else if (val.text !== undefined) val = val.text;
                    }
                    rowData[header] = val;
                }
            });
            data.push(rowData);
        }
    });
    return data;
}

// è·å–æ¸¯è‚¡å®æ—¶ä»·æ ¼ (API)
async function getHkStockPrice(code5Digit, hkTargetDataMap) {
    const cleanCode = String(code5Digit).trim().padStart(5, '0');
    
    // 1. å°è¯•ä» Excel æ•°æ®æ‰¾
    // hkTargetDataMap åªæ˜¯æœ€åä¸€å¤©çš„ { code: price }
    if (hkTargetDataMap && hkTargetDataMap[cleanCode]) {
        return parseFloat(hkTargetDataMap[cleanCode]);
    }

    // 2. å°è¯• API
    log(`æ­£åœ¨é€šè¿‡ API æŸ¥è¯¢æ¸¯è‚¡ ${cleanCode}...`);
    const fullCode = "HK" + cleanCode;
    const apiUrl = `https://aipeinvestmentagent.pages.dev/api/rtStockQueryProxy?code=${fullCode}&type=price`;
    try {
        const res = await axios.get(apiUrl, { timeout: 10000 });
        if (res.data && res.data.latestPrice > 0) {
            return parseFloat(res.data.latestPrice);
        }
    } catch (e) {
        console.warn("API Error", e);
    }
    return 0.0;
}

// ==================================================================================
// 4. ä¸šåŠ¡é€»è¾‘
// ==================================================================================

// æ¨¡æ‹Ÿä¸‹è½½å¹¶è§£ææ¸¯è‚¡æ•°æ®
async function loadHkData() {
    try {
        log(`æ­£åœ¨ä¸‹è½½æ¸¯è‚¡æ•°æ®: ${CONFIG.OSS_HK_DATA_PATH}`);
        const result = await client.get(CONFIG.OSS_HK_DATA_PATH);
        const buffer = result.content;
        
        const wb = new ExcelJS.Workbook();
        await wb.xlsx.load(buffer);
        const ws = wb.getWorksheet('ARHK');
        const rawData = sheetToJson(ws);
        
        // è½¬æ¢ç»“æ„ï¼š{ 'YYYY-MM-DD': { '00001': 100, ... } }
        const hkMap = {};
        
        rawData.forEach(row => {
            // ExcelJS è¯»å–æ—¥æœŸå¯èƒ½æ˜¯ Date å¯¹è±¡æˆ–å­—ç¬¦ä¸²
            let dateStr = row['æ—¥æœŸ'];
            if (dateStr instanceof Date) dateStr = moment(dateStr).format('YYYY-MM-DD');
            else dateStr = moment(String(dateStr)).format('YYYY-MM-DD');
            
            const code = String(row['ä»£ç ']).padStart(5, '0');
            const price = parseFloat(row['Price'] || row['æ”¶ç›˜ä»·']);
            
            if (!hkMap[dateStr]) hkMap[dateStr] = {};
            hkMap[dateStr][code] = price;
        });
        
        log(`æ¸¯è‚¡æ•°æ®åŠ è½½å®Œæˆï¼ŒåŒ…å« ${Object.keys(hkMap).length} ä¸ªäº¤æ˜“æ—¥`);
        return hkMap;
    } catch (e) {
        log(`âš ï¸ æ¸¯è‚¡æ•°æ®åŠ è½½å¤±è´¥ (å¯èƒ½æ˜¯æ–‡ä»¶ä¸å­˜åœ¨): ${e.message}`, 'error');
        return {};
    }
}

async function startProcess() {
    const btn = document.getElementById('startBtn');
    btn.disabled = true;
    log("=== ä»»åŠ¡å¼€å§‹ ===");

    try {
        // 1. åŠ è½½æ¸¯è‚¡æ•°æ®
        const hkDataFullMap = await loadHkData();
        // è·å–æ‰€æœ‰æ—¥æœŸå¹¶æ’åº
        const hkDates = Object.keys(hkDataFullMap).sort();
        const lastHkDate = hkDates[hkDates.length - 1];
        const hkTargetData = lastHkDate ? hkDataFullMap[lastHkDate] : {}; // ç”¨äºæœ€åæ›´æ–° Excel çš„æœ€æ–°ä»·æ ¼
        
        // 2. ä¸‹è½½ä¸» Excel
        log(`æ­£åœ¨ä¸‹è½½ Portfolio: ${CONFIG.OSS_REMOTE_PATH}`);
        const result = await client.get(CONFIG.OSS_REMOTE_PATH);
        const portfolioBuffer = result.content;
        
        const workbook = new ExcelJS.Workbook();
        await workbook.xlsx.load(portfolioBuffer);
        log("âœ… Excel åŠ è½½åˆ°å†…å­˜æˆåŠŸ");

        // æ¨¡æ‹Ÿ Aè‚¡è¡Œæƒ… (df_combined)
        // åœ¨æµè§ˆå™¨ä¸­æ— æ³•ç›´æ¥è¯»å–ç¯å¢ƒä¸­çš„ df_combinedï¼Œè¿™é‡Œå‡è®¾ä¸ºç©ºï¼Œæˆ–è€…ä½ éœ€è¦å†ä¸‹è½½ä¸€ä¸ªæ–‡ä»¶
        // å¦‚æœæ²¡æœ‰ Aè‚¡è¡Œæƒ…ï¼Œä¼šå¯¼è‡´å›æµ‹æ—¶éäº¤æ˜“æ—¥å¸‚å€¼è®¡ç®—ä¸å‡†ï¼Œä½†ä¸å½±å“æ ¸å¿ƒæµç¨‹
        const dfCombinedMap = {}; 

        const allStrategiesResults = {};
        const enginesCache = {};

        // 3. è¿è¡Œå›æµ‹
        for (const [key, config] of Object.entries(STRATEGY_MAP)) {
            log(`æ­£åœ¨å›æµ‹ç­–ç•¥: ${config.name}...`);
            const wsFlow = workbook.getWorksheet(config.sheet_flow);
            const wsSnap = workbook.getWorksheet(config.sheet_snap);
            
            if (!wsFlow || !wsSnap) {
                log(`è·³è¿‡ ${key}: æ‰¾ä¸åˆ° Worksheet`, 'error');
                continue;
            }

            const dataFlow = sheetToJson(wsFlow);
            const dataSnap = sheetToJson(wsSnap);

            const engine = new PortfolioBacktest(dataFlow, dataSnap, dfCombinedMap, hkDataFullMap);
            const history = engine.run();

            allStrategiesResults[key] = history;
            enginesCache[key] = engine;
        }

        // 4. ç”Ÿæˆ JSON æŠ¥å‘Š
        log("æ­£åœ¨ç”Ÿæˆ JSON æŠ¥å‘Š...");
        const jsonFilterDate = "2025-12-18";
        const jsonResults = {};
        
        // è¿‡æ»¤æ—¥æœŸ
        for(let key in allStrategiesResults) {
            jsonResults[key] = allStrategiesResults[key].filter(r => r['æ—¥æœŸ'] >= jsonFilterDate);
        }
        
        await generateAndUploadJson(jsonResults);

        // 5. æ›´æ–° Excel å¹¶ä¸Šä¼ 
        log("æ­£åœ¨æ›´æ–° Excel æ•°æ®...");
        await updateExcelAndUpload(workbook, enginesCache, hkTargetData);

        log("ğŸ‰ æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼", 'success');

    } catch (e) {
        log(`âŒ è‡´å‘½é”™è¯¯: ${e.message}`, 'error');
        console.error(e);
    } finally {
        btn.disabled = false;
    }
}

// ç”Ÿæˆ JSON å¹¶ä¸Šä¼ 
async function generateAndUploadJson(resultsDict) {
    // èšåˆæ•°æ®é€»è¾‘ (ç®€åŒ–ç‰ˆ)
    // æ‰¾å‡ºæ‰€æœ‰æ—¥æœŸ
    const dateSet = new Set();
    for(let k in resultsDict) {
        resultsDict[k].forEach(r => dateSet.add(r['æ—¥æœŸ']));
    }
    const sortedDates = Array.from(dateSet).sort();
    
    if(sortedDates.length === 0) {
        log("æ— æœ‰æ•ˆå›æµ‹æ•°æ®ï¼Œè·³è¿‡ JSON ç”Ÿæˆ", 'error');
        return;
    }

    const dailyDataList = [];
    const totalCurve = [];
    let initialTotal = 0;
    let globalMax = -Infinity;
    let maxDdSoFar = 0;

    // ç¼“å­˜ä¸Šä¸€æ—¥æ•°æ®ç”¨äºå¡«å……
    const lastVals = {};
    Object.keys(resultsDict).forEach(k => lastVals[k] = 0);

    sortedDates.forEach((date, idx) => {
        let dailySum = 0;
        Object.keys(resultsDict).forEach(k => {
            const dayRow = resultsDict[k].find(r => r['æ—¥æœŸ'] === date);
            if(dayRow) lastVals[k] = dayRow['æ€»èµ„äº§'];
            dailySum += lastVals[k];
        });

        if (dailySum <= 0) return;
        if (initialTotal === 0) initialTotal = dailySum;

        const prevSum = idx > 0 ? totalCurve[idx-1] : dailySum;
        const dailyRtn = prevSum > 0 ? (dailySum - prevSum) / prevSum : 0;
        const cumRtn = (dailySum - initialTotal) / initialTotal;

        if (dailySum > globalMax) globalMax = dailySum;
        const dd = (dailySum - globalMax) / globalMax;
        if (Math.abs(dd) > maxDdSoFar) maxDdSoFar = Math.abs(dd);

        totalCurve.push(dailySum);
        dailyDataList.push({
            "æ—¥æœŸ": date,
            "æ¯æ—¥æ”¶ç›Šç‡": dailyRtn,
            "ç´¯è®¡æ”¶ç›Šç‡": cumRtn,
            "æœ€å¤§å›æ’¤ç‡ï¼ˆè‡³å½“æ—¥ï¼‰": maxDdSoFar
        });
    });

    // è®¡ç®—å¹´åŒ–ä¸å¤æ™®
    const finalEquity = totalCurve[totalCurve.length - 1];
    const days = dailyDataList.length;
    const annRet = days > 1 ? Math.pow(finalEquity / initialTotal, 252 / days) - 1 : 0;
    
    const returns = dailyDataList.map(d => d['æ¯æ—¥æ”¶ç›Šç‡']);
    // ä½¿ç”¨ simple-statistics åº“è®¡ç®—
    const mean = ss.mean(returns);
    const std = ss.standardDeviation(returns);
    const sharpe = std !== 0 ? (mean / std) * Math.sqrt(252) : 0;

    const outputData = {
        "æ¨¡å‹åç§°": "Useræ¨¡å‹",
        "æ€»æ”¶ç›Šç‡": dailyDataList[dailyDataList.length - 1]['ç´¯è®¡æ”¶ç›Šç‡'],
        "å¹´åŒ–æ”¶ç›Šç‡": annRet,
        "æœ€å¤§å›æ’¤ç‡": maxDdSoFar,
        "å¤æ™®æ¯”ç‡": sharpe,
        "æ¯æ—¥è¯„ä¼°æ•°æ®": dailyDataList
    };

    // ä¸Šä¼  JSON å­—ç¬¦ä¸²
    const jsonString = JSON.stringify(outputData, null, 4);
    const blob = new Blob([jsonString], { type: 'application/json' });
    
    await client.put(CONFIG.OSS_JSON_PATH, blob);
    log(`âœ… JSON æŠ¥å‘Šå·²ä¸Šä¼ è‡³ OSS: ${CONFIG.OSS_JSON_PATH}`, 'success');
}

// æ›´æ–° Excel å†…å®¹
async function updateExcelAndUpload(workbook, enginesCache, hkTargetData) {
    if (Object.keys(enginesCache).length === 0) return;

    // å–å‡ºä¸€ä¸ªå¼•æ“è·å–æœ€æ–°æ—¥æœŸ
    const sampleEngine = Object.values(enginesCache)[0];
    const lastDateFmt = sampleEngine.allDates[sampleEngine.allDates.length - 1]; // "YYYY-MM-DD"
    const lastDateCompact = moment(lastDateFmt).format('YYYYMMDD');
    const targetTimeStr = lastDateCompact + "1630";

    const sheetToKey = {};
    for (let k in STRATEGY_MAP) sheetToKey[STRATEGY_MAP[k].sheet_snap] = k;

    // ä»·æ ¼æŸ¥è¯¢è¡¨ (åŸºäºæœ€åä¸€å¤©çš„è¡Œæƒ…)
    const rawMarket = sampleEngine.marketMap[lastDateFmt] || {};
    // è½¬ä¸º { '6ä½ä»£ç ': price }
    const priceMap = {};
    for(let k in rawMarket) {
        priceMap[String(k).split('.')[0].trim()] = rawMarket[k];
    }

    const sheets = ['ADHOC', 'ä½æ³¢', 'å¤§æˆ', 'æµå…¥', 'å¤§æ™º'];
    
    // è¾…åŠ©: è·å–ä»·æ ¼
    async function getPrice(code) {
        const c = String(code).split('.')[0].trim();
        if (c === '100000') return 1.0;
        let p = priceMap[c];
        
        if (!p || p === 0) {
            // æŸ¥æ¸¯è‚¡ç¼“å­˜
            const hkCode = c.slice(-5);
            const hkP = await getHkStockPrice(hkCode, hkTargetData);
            if (hkP) p = hkP;
        }
        return p || 0.0;
    }

    for (let sheetName of sheets) {
        const ws = workbook.getWorksheet(sheetName);
        if (!ws) continue;

        // æ˜ å°„è¡¨å¤´åˆ—ç´¢å¼•
        const headerRow = ws.getRow(1);
        const colMap = {};
        headerRow.eachCell((cell, colNum) => {
            const val = cell.value ? String(cell.value).trim() : '';
            if(val) colMap[val] = colNum;
        });

        if (!colMap['è‚¡ç¥¨ä»£ç '] || !colMap['ä¿®æ”¹æ—¶é—´']) continue;

        // è®¡ç®—ç­–ç•¥æƒé‡
        const strategyKey = sheetToKey[sheetName];
        const weightMap = {};
        
        if (strategyKey && enginesCache[strategyKey]) {
            const eng = enginesCache[strategyKey];
            let currentEquity = eng.cash;
            // è®¡ç®—æœ€æ–°å¸‚å€¼
            for (let c in eng.positions) {
                currentEquity += (eng.positions[c] * await getPrice(c));
            }
            if (currentEquity > 0) {
                weightMap['100000'] = (eng.cash / currentEquity) * 100;
                for (let c in eng.positions) {
                    const fmtC = String(c).split('.')[0].trim();
                    const val = eng.positions[c] * await getPrice(c);
                    weightMap[fmtC] = (val / currentEquity) * 100;
                }
            }
            log(`   [${sheetName}] è®¡ç®—æƒé‡å®Œæ¯•, èµ„äº§: ${Math.round(currentEquity)}`);
        }

        // æ‰«æè¡Œè¿›è¡Œæ›´æ–°
        let targetRows = [];
        let maxDateStr = "";
        let templateRows = []; // å¦‚æœéœ€è¦æ–°å¢æ—¥æœŸï¼Œç”¨æ¥å¤åˆ¶çš„è¡Œ

        ws.eachRow((row, rowNum) => {
            if (rowNum === 1) return;
            
            const timeVal = row.getCell(colMap['ä¿®æ”¹æ—¶é—´']).value;
            const timeStr = timeVal ? String(timeVal).trim() : "";
            const datePart = timeStr.substring(0, 8);
            
            if (datePart === lastDateCompact) {
                targetRows.push(row);
            }
            
            if (datePart > maxDateStr) {
                maxDateStr = datePart;
                templateRows = [row]; // é‡ç½®
            } else if (datePart === maxDateStr) {
                templateRows.push(row);
            }
        });

        // å¦‚æœæ˜¯ ADHOCï¼Œæ›´æ–°æ‰€æœ‰è¡Œï¼›å¦åˆ™åªæ›´æ–°å½“å¤©
        if (sheetName === 'ADHOC') {
            // ADHOC é‡æ–°æ‰«ææ‰€æœ‰è¡Œ
             ws.eachRow((row, rowNum) => { if(rowNum > 1) targetRows.push(row); });
        } else if (targetRows.length === 0 && templateRows.length > 0) {
            // éœ€è¦æ–°å¢è¡Œ
            log(`   [${sheetName}] æ–°å¢æ—¥æœŸ ${lastDateCompact} (å¤åˆ¶è‡ª ${maxDateStr})`);
            for (let tRow of templateRows) {
                // ExcelJS insertRow æˆ– addRow
                // è¿™é‡Œç®€å•å¤„ç†ï¼šåœ¨è¡¨æ ¼æœ«å°¾è¿½åŠ 
                const newValues = JSON.parse(JSON.stringify(tRow.values)); // æ·±æ‹·è´å€¼
                const newRow = ws.addRow(newValues);
                targetRows.push(newRow);
            }
        } else {
            log(`   [${sheetName}] æ›´æ–°ç°æœ‰æ—¥æœŸ ${lastDateCompact}`);
        }

        // æ‰§è¡Œå•å…ƒæ ¼æ›´æ–°
        for (let row of targetRows) {
            const rawCode = row.getCell(colMap['è‚¡ç¥¨ä»£ç ']).value;
            const fmtCode = String(rawCode).split('.')[0].trim();
            
            // 1. æ›´æ–°ä»·æ ¼
            if (colMap['æ”¶ç›˜ä»·æ ¼']) {
                const price = await getPrice(fmtCode);
                row.getCell(colMap['æ”¶ç›˜ä»·æ ¼']).value = price;
            }
            
            // 2. æ›´æ–°æ—¶é—´
            if (sheetName !== 'ADHOC') {
                row.getCell(colMap['ä¿®æ”¹æ—¶é—´']).value = targetTimeStr;
            }
            
            // 3. æ›´æ–°æƒé‡
            if (colMap['é…ç½®æ¯”ä¾‹ (%)'] && weightMap[fmtCode] !== undefined) {
                row.getCell(colMap['é…ç½®æ¯”ä¾‹ (%)']).value = weightMap[fmtCode];
            }
        }
    }

    // ä¿å­˜ Buffer å¹¶ä¸Šä¼ 
    const buffer = await workbook.xlsx.writeBuffer();
    // è½¬æ¢ä¸º Blob ç”¨äº ali-oss ä¸Šä¼ 
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    
    log(`æ­£åœ¨ä¸Šä¼ æ›´æ–°åçš„ Excel: ${CONFIG.OSS_REMOTE_PATH}`);
    await client.put(CONFIG.OSS_REMOTE_PATH, blob);
    log(`âœ… Excel æ›´æ–°å¹¶ä¸Šä¼ æˆåŠŸï¼`, 'success');
}

</script>
</body>
</html>
